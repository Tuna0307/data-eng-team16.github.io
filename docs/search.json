[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Eng Team 16 Project Proposal",
    "section": "",
    "text": "1. Chosen Data Visualization\nWe selected the visualization from the Straits Times article: “Older buyers, smaller households among factors driving demand for smaller flats”\nThe featured chart depicts the percentage increase in HDB resale flat transactions from 2020 to 2024, categorized by flat type. Notably, it shows a 90.7% surge in transactions for 2-room flats, which strongly contrasts with more modest increases for 4-room and 5-room units. This visualization attributes these changes to several key demographic trends:\n\nA growing population of elderly citizens (aged 65 and above), many of whom seek to right-size their homes.\nA steady decline in average household size, falling from 3.5 persons in 2000 to approximately 2.9 in recent years.\nA rise in single-person and two-person households, particularly due to later marriages and aging-in-place.\nIncreased policy flexibility and supply of smaller flats, such as 2-room Flexi schemes, catering to senior citizens and singles.\n\nThis visualization is highly relevant for our project because it offers a clear example of how population ageing and evolving household structures directly influence public housing demand. By enhancing this static chart with dynamic and multi-dimensional data, we aim to uncover deeper patterns in demand across flat types, regions, and years. The outcome could help inform urban development policy and strategies for future housing allocation in Singapore’s maturing society.\n\nOriginal Visualisation 1\n\n\n\nFigure 1: Percentage Change in Resale Price of HDB flats\n\n\n\n\n\n2. Critical Analysis of the Original Visualization\n\nStrengths\n\nClarity and Simplicity: The bar chart effectively presents percentage change data in a manner that is straightforward and accessible, making it suitable for general readers without a technical background.\nEffective Comparison: By organizing the data by flat type, it allows readers to quickly identify which segments of the market are experiencing the fastest growth.\nContextual Relevance: The chart aligns well with the narrative in the article, which explores how social and demographic shifts are shaping the HDB resale landscape.\nClear Labeling: The use of bold titles and explicit labeling helps establish context immediately.\n\n\n\nWeaknesses\n\nLimited Granularity of Insights: The visualization presents an aggregated view of percentage changes across flat types over a four-year period, but it lacks finer granularity. It does not show:\n\nYear-on-year variation, which is critical for identifying short-term market shifts (e.g. policy impacts or economic shocks).\nTown-level or estate-specific data, which prevents detection of spatial patterns or localized demand pressures.\nDemographic segmentation (e.g. age groups, household size, income tiers), which limits the ability to assess how different population segments are influencing demand for smaller flats.\n\nLack of Interactivity and Customization: The static nature of the graphic restricts user engagement and exploration. Viewers are presented with a single, author-defined view of the data and cannot:\n\nFilter by specific years or towns.\nFocus on individual flat types or demographics.\nConduct self-guided analysis.\n\nMinimal Analytical Depth: The original chart is purely descriptive, presenting a one-dimensional summary of percentage change. It does not:\n\nShow base figures or total transaction volumes, making the percentage change potentially misleading.\nProvide contextual explanations (e.g. why 2-room demand increased, or how policy changes like Enhanced CPF Housing Grant may have influenced behavior).\n\n\n\n\n\n3. Planned Improvements\nTo overcome the limitations and offer a more robust and informative visual analysis, our team will develop an interactive dashboard incorporating the following enhancements:\n\nTime Series Visualization: Instead of one aggregated bar chart, we will plot monthly or quarterly transaction volumes from 2017 to 2025. This will reveal how demand evolved in relation to macroeconomic events, housing policies (e.g. cooling measures), and demographic changes.\nGeospatial Mapping: Using HDB town data, we will develop a Singapore map highlighting average resale prices and transaction volumes by region. This will help surface spatial disparities and allow for estate-level insights.\nInteractive Filters: The dashboard will include filters by flat type, town, and year. This will allow users (including policymakers or researchers) to explore patterns relevant to their context.\nCorrelation Visuals: Bubble charts or scatter plots will be used to examine relationships between floor area, resale price, and transaction volume. For example, we can test whether smaller flats in certain towns yield higher per-square-meter prices due to constrained supply.\nDemographic Overlay (if available): If demographic data by town is available, we will attempt to link population structure with housing demand to test assumptions about elderly and single buyers.\n\nOur final dashboard will offer clear, interactive, and multi-layered views that go beyond what a single static image can provide.\n\n\n4. Details of Data Source\nOur primary dataset will come from the HDB Resale Flat Prices repository on data.gov.sg, which offers a granular and authoritative view of public housing resale activity. Key features of this dataset include:\n\nTime Coverage: Monthly records from January 1990 through June 2025.\nAttributes:\n\nFlat type (e.g. 2-room, 3-room, 4-room, etc.)\nFlat model and floor area (in sqm)\nTown and block-level location\nMonth of transaction\nResale price (in SGD)\nStorey range (e.g. 04–06, 10–12)\n\n\nThe dataset is updated monthly and is widely used in public research, making it ideal for reproducible, policy-relevant visual analysis.\nAdditional contextual data will be sourced from SingStat for: - Population by age group - Household size and composition over time - Marital status and homeownership patterns\nTogether, these datasets will enable us to connect population dynamics to housing outcomes more rigorously.\nSample of Raw Data from HDB Resale Flat Prices (data.gov.sg)\n\n\n\n\n\n\n\n\n\n\n\n\n\nmonth\ntown\nflat_type\nblock\nstreet_name\nstorey_range\nfloor_area_sqm\nresale_price\n\n\n\n\n2024-01\nANG MO KIO\n2 ROOM\n406\nANG MO KIO AVE 10\n04 TO 06\n44\n315000\n\n\n2024-01\nANG MO KIO\n3 ROOM\n108\nANG MO KIO AVE 4\n01 TO 03\n67\n342000\n\n\n2024-01\nBEDOK\n4 ROOM\n516\nBEDOK NTH AVE 2\n07 TO 09\n92\n535000\n\n\n2024-01\nBUKIT MERAH\n5 ROOM\n108\nHENDERSON CRES\n10 TO 12\n117\n968000\n\n\n2024-01\nCLEMENTI\n3 ROOM\n377\nCLEMENTI AVE 5\n01 TO 03\n67\n365000\n\n\n\n\n\n5. Steps for Data Cleaning and Transformation\nTo prepare our data for rigorous analysis and visualization within the R environment, we will follow a structured workflow using core R packages, primarily from the tidyverse suite.\n\n5.1. Data Loading and Initial Inspection\n\nAction: The “Resale Flat Prices” dataset will be downloaded as a CSV file. We will load it into RStudio using the readr::read_csv() function to create a tibble (a modern data frame).\nPurpose: This initial step allows us to perform a preliminary assessment of the dataset’s structure using functions like glimpse(), summary(), and head() to understand its dimensions, variable types, and overall content before proceeding with cleaning.\n\n\n\n5.2. Missing Value Handling and Data Integrity\n\nAction: We will use the naniar or visdat package to visualize missing data patterns and dplyr::summarise() to quantify NA values in critical columns like resale_price, floor_area_sqm, and storey_range.\nPurpose: Identifying and addressing missing data is crucial for accurate modeling. For any NA values, we will evaluate the best strategy. If records with missing data are minimal, we may filter them out using na.omit() or tidyr::drop_na(). For more significant gaps, we will consider imputation, potentially using the median value for a given town and flat type to preserve the data’s distribution.\n\n\n\n5.3. Data Type Conversion\n\nAction: We will convert variable types to ensure they are appropriate for analysis. The month column (e.g., “2023-05”) will be parsed into a proper Date object using the lubridate::ym() function. Other columns like resale_price and floor_area_sqm will be ensured to be of numeric type using as.numeric().\nPurpose: Correct data types are essential for R functions to work correctly. Converting month to a Date object is critical for enabling time-series analysis, creating rolling averages, and plotting chronological trends.\n\n\n\n5.4. Feature Engineering\nUsing dplyr::mutate(), we will create several new, more informative variables:\n\nTemporal Features: We will use lubridate functions like year() and quarter() on our new Date column to extract the year and quarter, facilitating aggregation and trend analysis at different time scales.\nPrice per Square Metre (PSM): A new column, price_per_sqm, will be calculated by dividing resale_price by floor_area_sqm. This normalization is key to comparing property values fairly across different flat sizes and locations.\nStorey Level Conversion: The storey_range (e.g., “01 TO 03”) will be converted into a numeric variable. We will use stringr functions to extract the lower and upper bounds of the range and calculate the midpoint, allowing us to analyze the relationship between storey height and price.\n\n\n\n5.5. Data Aggregation and Integration\n\nAction: We will leverage dplyr::group_by() and dplyr::summarise() to aggregate the cleaned data. This will allow us to create summary tables based on dimensions like town, flat_type, and year.\nPurpose: Aggregated data is the foundation for our visualizations and high-level analysis. It will enable us to calculate key metrics such as mean/median price_per_sqm by town, which is necessary for creating choropleth maps, or by time period for generating time-series plots. If external demographic data is used, it will be joined to our main dataset using a dplyr::left_join() operation on a common key like town.\n\n\n\n\n6. Data Analysis Plan\nOur analysis will aim to provide evidence-backed insights on how demand for smaller flats has evolved in response to demographic shifts. The main areas of analysis include:\n\nDescriptive Statistics: Calculate averages, medians, and distribution patterns of resale prices and floor areas segmented by flat type and location.\nTrend Analysis:\n\nTrack year-on-year changes in both transaction volume and resale price for 2-room, 3-room, and larger flats.\nIdentify notable spikes or dips in relation to external factors.\n\nSpatial Analysis:\n\nMap average prices and volume by town to identify hotspots of demand.\nHighlight any regional inequalities in pricing or transaction growth.\n\nCorrelation Analysis:\n\nInvestigate links between demographic indicators and demand for smaller flats.\nTest if towns with higher aging populations see greater price growth in 2-room resale units.\n\nExploratory Insights:\n\nObserve whether price appreciation in smaller flats is outpacing larger units, potentially indicating shrinking supply or over-demand.\n\n\nThe outcome of our analysis will serve to validate, challenge, or deepen the conclusions drawn in the original news article.\n\n\n7. Work Allocation\n\n\n\n\n\n\n\n\n\nTask\nPrimary Lead(s)\nSupporting Member(s)\nDescription\n\n\n\n\nData Sourcing & Cleaning\nJiarui\nWeixuan\nResponsible for downloading the datasets from data.gov.sg and SingStat, loading them into R, and performing initial cleaning. This includes handling missing values (NA), correcting data types, and ensuring data integrity.\n\n\nFeature Engineering & Transformation\nWeixuan\nJiarui\nBuilds upon the cleaned data to create new, analytical variables. Key tasks include calculating price_per_sqm, converting the storey_range into a numeric variable, and extracting year and quarter for time-series analysis.\n\n\nExploratory Data Analysis (EDA) & Hypothesis Testing\nElsia\nJiarui, Weixuan\nConducts the initial statistical analysis to uncover patterns and validate assumptions. This involves creating summary statistics, generating preliminary plots (histograms, boxplots), and investigating initial trends to guide the final dashboard design.\n\n\nInteractive Dashboard Development (Core & Time Series)\nHaris\nShi Wei\nLeads the development of the main interactive dashboard using flexdashboard or Shiny. This includes setting up the overall layout, implementing core interactive filters (by town, flat type, year), and building the primary time-series visualization.\n\n\nGeospatial & Correlation Visualizations\nShi Wei\nHaris, Elsia\nFocuses on developing the specialized visualizations for the dashboard. This includes creating the choropleth map to show spatial patterns by town and building the bubble/scatter plots to visualize correlations between price, floor area, and transaction volume."
  },
  {
    "objectID": "HDB Resale Analysis and Visualization.html",
    "href": "HDB Resale Analysis and Visualization.html",
    "title": "HDB Resale Trends: Analysis and Enhanced Visualization",
    "section": "",
    "text": "This document validates our cleaned data against the original Straits Times article, reconstructs the article’s visualizations, and presents three new, improved charts to uncover deeper insights into the HDB resale market from 2020-2024.\n\n\n\nThis first step loads the necessary libraries and reads the clean CSV files that were created by our data_cleaning.qmd script.\n\n# --- 1. Setup and Load All Data ---\n\n# List of required packages for analysis and visualization\npackages &lt;- c(\"tidyverse\", \"lubridate\", \"scales\", \"forcats\", \"ggridges\", \"plotly\", \"sf\",\"patchwork\")\n\n# Loop through each package\nfor (pkg in packages) {\n  # Install the package if it's not already installed\n  if (!require(pkg, character.only = TRUE)) {\n    install.packages(pkg)\n  }\n  # Load the package\n  library(pkg, character.only = TRUE)\n}\n\n# Set global options for cleaner output\noptions(scipen = 999)\noptions(dplyr.summarise.inform = FALSE)\n\n# --- Load the CLEAN datasets from the previous script ---\n# Make sure these files are in a \"data_output\" subfolder.\nproject_data &lt;- read_csv(\"data_output/cleaned_hdb_resale_data.csv\")\npercentage_change &lt;- read_csv(\"data_output/percentage_change_analysis.csv\")\n\n# Confirm that data is loaded\ncat(\"Clean data loaded successfully. project_data has\", nrow(project_data), \"rows.\\n\")\n\nClean data loaded successfully. project_data has 127606 rows.\n\n\n\n\n\n\nWe first check if our data matches the key statistics cited in the article. This confirms the quality of our data preparation.\n\n# --- Validation 1: Transaction Counts (Jan-Nov) ---\ntransaction_validation &lt;- project_data %&gt;%\n  filter(month(month) &lt;= 11) %&gt;%\n  filter(flat_type == \"2 ROOM\", year %in% c(2020, 2024)) %&gt;%\n  group_by(year) %&gt;%\n  summarise(transaction_count = n())\n\nprint(\"Validation - 2-Room Transaction Counts (Jan-Nov):\")\n\n[1] \"Validation - 2-Room Transaction Counts (Jan-Nov):\"\n\nprint(transaction_validation)\n\n# A tibble: 2 × 2\n   year transaction_count\n  &lt;dbl&gt;             &lt;int&gt;\n1  2020               386\n2  2024               731\n\ncat(\"Article cited 388 (2020) and 740 (2024).\\n\\n\")\n\nArticle cited 388 (2020) and 740 (2024).\n\n# --- Validation 2 & 3: Median Prices (Q4) ---\nprice_validation &lt;- project_data %&gt;%\n  filter(quarter(month, with_year = FALSE) == 4) %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\"), year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(median_price = median(resale_price, na.rm = TRUE)) %&gt;%\n  arrange(flat_type, year)\n\nprint(\"Validation - Median Prices in Q4:\")\n\n[1] \"Validation - Median Prices in Q4:\"\n\nprint(price_validation)\n\n# A tibble: 4 × 3\n# Groups:   flat_type [2]\n  flat_type  year median_price\n  &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 2 ROOM     2020       238000\n2 2 ROOM     2024       355000\n3 3 ROOM     2020       305000\n4 3 ROOM     2024       424000\n\ncat(\"Article cited $238k/$353k for 2-room and $308k/$430k for 3-room.\\n\")\n\nArticle cited $238k/$353k for 2-room and $308k/$430k for 3-room.\n\n\n\n\n\n\nUsing our validated data, we recreate the two simple bar charts from the news article for direct comparison.\n\n\n\nggplot(percentage_change, \n       aes(x = percentage_change, \n           y = fct_reorder(flat_type_label, percentage_change))) +\n  geom_col(aes(fill = percentage_change &gt; 0), show.legend = FALSE) +\n  geom_text(aes(label = paste0(percentage_change, \"%\")), hjust = -0.15, size = 3.5, color = \"black\") +\n  scale_fill_manual(values = c(\"TRUE\" = \"#5D9CEC\", \"FALSE\" = \"#D9D9D9\")) +\n  scale_x_continuous(limits = c(-30, 100), breaks = seq(-30, 90, 10)) +\n  labs(\n    title = \"Recreation: Percentage Change in HDB Transactions\",\n    subtitle = \"From 2020 to 2024, based on our prepared data\",\n    x = NULL, y = NULL, caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), plot.title.position = \"plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n# Prepare data for the price change chart\nprice_change_summary &lt;- project_data %&gt;%\n  filter(year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(median_price = median(resale_price, na.rm = TRUE), .groups = \"drop\") %&gt;%\n  complete(flat_type, year = c(2020, 2024), fill = list(median_price = 0)) %&gt;%\n  pivot_wider(names_from = year, values_from = median_price, names_prefix = \"year_\") %&gt;%\n  mutate(\n    price_change_pct = if_else(year_2020 &gt; 0, round(((year_2024 - year_2020) / year_2020) * 100, 1), NA_real_),\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  ) %&gt;%\n  filter(!is.na(price_change_pct))\n\n# Recreate the price change chart\nggplot(price_change_summary, \n       aes(x = price_change_pct, \n           y = fct_reorder(flat_type_label, price_change_pct))) +\n  geom_col(aes(fill = flat_type %in% c(\"2 ROOM\", \"3 ROOM\")), show.legend = FALSE) +\n  geom_text(aes(label = paste0(price_change_pct, \"%\")), hjust = -0.15, size = 3.5, color = \"black\") +\n  scale_fill_manual(values = c(\"TRUE\" = \"#5D9CEC\", \"FALSE\" = \"#D9D9D9\")) +\n  scale_x_continuous(limits = c(0, 50), breaks = seq(0, 90, 10)) +\n  labs(\n    title = \"Recreation: Percentage Change in Resale Price\",\n    subtitle = \"From 2020 to 2024, based on our prepared data\",\n    x = NULL, y = NULL, caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), plot.title.position = \"plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe original charts are simple bar charts. We can create far more insightful and visually appealing charts by exploring distributions, trends over time, and spatial patterns in the data.\n\n\nA ridgeline plot shows the full range of prices, not just a single number. This reveals the significant overlap in prices between different flat types.\n\nif (!require(\"ggridges\")) {\n  install.packages(\"ggridges\")\n}\nlibrary(ggridges)\n\n# --- CORRECTED CODE ---\n# Prepare data with a clean label for plotting\nplot_data &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(\n    # Create the clean label (e.g., \"2 ROOM\" -&gt; \"2-Room\")\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  )\n\n# This ggplot call will now work correctly because `flat_type_label` exists\nggplot(plot_data, aes(x = resale_price, y = fct_rev(flat_type_label), fill = flat_type_label)) +\n  geom_density_ridges(alpha = 0.8, scale = 1.5) +\n  scale_x_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = \"k\")) +\n  labs(\n    title = \"Improved Viz: Price Distribution Varies Significantly by Flat Type\",\n    subtitle = \"Distribution of HDB resale prices from 2020-2024. Note the wide overlap.\",\n    x = \"Resale Price (S$)\",\n    y = NULL,\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title.position = \"plot\") \n\n\n\n\n\n\n\n\n\n\n\nA time series plot showing how prices evolved monthly, with smooth trend lines and confidence intervals.\n\n# Prepare monthly trend data\nmonthly_trends &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title(),\n    year_month = floor_date(month, \"month\")\n  ) %&gt;%\n  group_by(year_month, flat_type_label) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    q25 = quantile(resale_price, 0.25, na.rm = TRUE),\n    q75 = quantile(resale_price, 0.75, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Create an elegant time series plot\nggplot(monthly_trends, aes(x = year_month, y = median_price, color = flat_type_label, fill = flat_type_label)) +\n  geom_ribbon(aes(ymin = q25, ymax = q75), alpha = 0.2, color = NA) +\n  geom_line(size = 1.2, alpha = 0.9) +\n  geom_point(size = 1.5, alpha = 0.8) +\n  scale_x_date(\n    date_labels = \"%Y-%m\",\n    date_breaks = \"6 months\",\n    expand = c(0.02, 0.02)\n  ) +\n  scale_y_continuous(\n    labels = scales::dollar_format(scale = 1e-3, suffix = \"K\"),\n    breaks = scales::pretty_breaks(n = 6)\n  ) +\n  scale_color_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(\n    title = \"HDB Resale Price Trends Over Time\",\n    subtitle = \"Monthly median prices with interquartile ranges (ribbons) showing market volatility\",\n    x = \"Year-Month\",\n    y = \"Median Resale Price (S$)\",\n    color = \"Flat Type\",\n    fill = \"Flat Type\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.margin = margin(20, 20, 20, 20)\n  ) +\n  guides(\n    color = guide_legend(override.aes = list(size = 3)),\n    fill = guide_legend(override.aes = list(alpha = 0.3))\n  )\n\n\n\n\n\n\n\n\n\n\n\nA modern scatter plot with trend lines and marginal distributions showing the relationship between floor height and price efficiency.\n\n# Prepare data for storey analysis\nstorey_analysis &lt;- project_data %&gt;%\n  filter(\n    flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\"),\n    storey_mid &lt;= 50, # Remove extreme outliers\n    price_per_sqm &gt; 0 & price_per_sqm &lt; 15000 # Remove price outliers\n  ) %&gt;%\n  mutate(\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title(),\n    storey_group = case_when(\n      storey_mid &lt;= 5 ~ \"Low (1-5)\",\n      storey_mid &lt;= 10 ~ \"Mid-Low (6-10)\",\n      storey_mid &lt;= 15 ~ \"Mid (11-15)\",\n      storey_mid &lt;= 20 ~ \"Mid-High (16-20)\",\n      TRUE ~ \"High (21+)\"\n    ),\n    storey_group = factor(storey_group, levels = c(\"Low (1-5)\", \"Mid-Low (6-10)\", \"Mid (11-15)\", \"Mid-High (16-20)\", \"High (21+)\"))\n  )\n\n# Create an enhanced box plot for clearer trend analysis\nggplot(storey_analysis, \n       aes(x = storey_group, y = price_per_sqm, fill = storey_group)) +\n  geom_boxplot(alpha = 0.8, outlier.shape = NA) + # Hiding outliers for clarity\n  scale_y_continuous(\n    labels = scales::dollar_format(prefix = \"S$\"),\n    limits = quantile(storey_analysis$price_per_sqm, c(0.01, 0.99), na.rm = TRUE) # Zoom in\n  ) +\n  scale_fill_viridis_d(option = \"cividis\", guide = \"none\") +\n  facet_wrap(~flat_type_label, scales = \"free_y\", ncol = 3) +\n  labs(\n    title = \"Price per Sqm Distribution by Storey Height\",\n    subtitle = \"Box plots clearly show increasing price efficiency with height, faceted by flat type\",\n    x = \"Storey Group\",\n    y = \"Price per Square Meter (S$)\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    panel.grid.minor = element_blank(),\n    strip.text = element_text(face = \"bold\", size = 11),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.margin = margin(20, 20, 20, 20)\n  )\n\n\n\n\n\n\n\n\n\n\n\nA modern horizontal bar chart showing median prices by town, with interactive tooltips when rendered in HTML.\n\n# Prepare town-wise analysis\ntown_analysis &lt;- project_data %&gt;%\n  group_by(town) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    transaction_count = n(),\n    .groups = \"drop\"\n  ) %&gt;%\n  filter(transaction_count &gt;= 50) %&gt;% # Only include towns with sufficient data\n  arrange(desc(median_price)) %&gt;%\n  mutate(\n    town_rank = row_number(),\n    price_category = case_when(\n      median_price &gt;= 600000 ~ \"Premium (≥S$600K)\",\n      median_price &gt;= 450000 ~ \"High (S$450K-600K)\",\n      median_price &gt;= 350000 ~ \"Mid (S$350K-450K)\",\n      TRUE ~ \"Affordable (&lt;S$350K)\"\n    ),\n    price_category = factor(price_category, levels = c(\"Premium (≥S$600K)\", \"High (S$450K-600K)\", \"Mid (S$350K-450K)\", \"Affordable (&lt;S$350K)\"))\n  ) %&gt;%\n  slice_head(n = 20) # Show top 20 towns\n\n# Step 1: Create the ggplot object with a 'text' aesthetic for the tooltip\np_towns &lt;- ggplot(town_analysis, \n                  aes(x = median_price, y = fct_reorder(town, median_price), fill = price_category,\n                      # Define the custom tooltip content here\n                      text = paste(\"Town:\", town, \n                                   \"\\nMedian Price:\", scales::dollar(median_price),\n                                   \"\\nMedian PSM:\", scales::dollar(median_psm),\n                                   \"\\nTransactions:\", transaction_count))) +\n  geom_col(alpha = 0.8, width = 0.7) +\n  scale_x_continuous(\n    labels = scales::dollar_format(scale = 1e-3, suffix = \"K\"),\n    expand = expansion(mult = c(0, 0.15)) # Make space for labels/tooltips\n  ) +\n  scale_fill_manual(values = c(\n    \"Premium (≥S$600K)\" = \"#E31A1C\",\n    \"High (S$450K-600K)\" = \"#FF7F00\", \n    \"Mid (S$350K-450K)\" = \"#1F78B4\",\n    \"Affordable (&lt;S$350K)\" = \"#33A02C\"\n  )) +\n  labs(\n    title = \"Interactive Top 20 HDB Towns by Median Resale Price\",\n    subtitle = \"Ranked by median price (2020-2024). Hover on bars for details.\",\n    x = \"Median Resale Price (S$)\",\n    y = NULL,\n    fill = \"Price Category\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    legend.position = \"bottom\",\n    panel.grid.major.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"),\n    plot.margin = margin(20, 20, 20, 20)\n  )\n\n# Step 2: Convert the ggplot object to an interactive plotly chart\nplotly::ggplotly(p_towns, tooltip = \"text\")\n\n\n\n\n\n\n\n\nThis multi-panel dashboard, built with the patchwork package, provides a powerful, at-a-glance summary of the HDB resale market, combining price trends, transaction volumes, and market share into a single, cohesive view.\n\n# Prepare summary statistics for the dashboard\nsummary_stats &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title()) %&gt;%\n  group_by(flat_type_label, year) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    transaction_count = n(),\n    .groups = \"drop\"\n  )\n\n# Panel 1: Price evolution by year\np1 &lt;- ggplot(summary_stats, aes(x = year, y = median_price, color = flat_type_label)) +\n  geom_line(size = 1.2, alpha = 0.9) +\n  geom_point(size = 2) +\n  scale_x_continuous(breaks = 2020:2024) +\n  scale_y_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = \"K\")) +\n  scale_color_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(title = \"A. Price Evolution by Year\", x = NULL, y = \"Median Price\", color = \"Flat Type\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), legend.title = element_text(face=\"bold\"))\n\n# Panel 2: Transaction volume by year\np2 &lt;- ggplot(summary_stats, aes(x = year, y = transaction_count, fill = flat_type_label)) +\n  geom_col(position = \"stack\", alpha = 0.8) +\n  scale_x_continuous(breaks = 2020:2024) +\n  scale_y_continuous(labels = scales::comma) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(title = \"B. Transaction Volume by Year\", x = NULL, y = \"Transactions\", fill = \"Flat Type\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), legend.title = element_text(face=\"bold\"))\n\n# Panel 3: Price per sqm comparison\np3 &lt;- ggplot(summary_stats %&gt;% filter(year %in% c(2020, 2024)), \n             aes(x = fct_reorder(flat_type_label, median_psm), y = median_psm, fill = factor(year))) +\n  geom_col(position = \"dodge\", alpha = 0.8) +\n  scale_y_continuous(labels = scales::dollar_format(prefix = \"S$\")) +\n  scale_fill_manual(values = c(\"2020\" = \"#440154FF\", \"2024\" = \"#FDE725FF\"), name = \"Year\") +\n  labs(title = \"C. Price per Sqm: 2020 vs 2024\", x = NULL, y = \"Median PSM\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), axis.text.x = element_text(angle=45, hjust=1), legend.title = element_text(face=\"bold\"))\n\n# Panel 4: Market share by flat type in the last full year\n# We use 2023 for a full year's data, as 2024 is incomplete.\nmarket_share &lt;- summary_stats %&gt;%\n  group_by(year) %&gt;%\n  mutate(market_share = transaction_count / sum(transaction_count)) %&gt;%\n  ungroup() %&gt;%\n  filter(year == 2023)\n\np4 &lt;- ggplot(market_share, aes(x = \"\", y = market_share, fill = fct_reorder(flat_type_label, market_share))) +\n  geom_col(width = 1, alpha = 0.8) +\n  coord_polar(\"y\", start = 0) +\n  geom_text(aes(label = scales::percent(market_share, accuracy = 1)), \n            position = position_stack(vjust = 0.5), color = \"white\", fontface = \"bold\") +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9, guide=\"none\") +\n  labs(title = \"D. Market Share by Flat Type (2023)\") +\n  theme_void(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n# --- FIX IS HERE ---\n# Combine all panels using patchwork.\n# We wrap the main plot composition in parentheses to ensure it's evaluated\n# fully before the `&` operator is applied. This resolves the precedence issue.\n(\n  (p1 + p2) / (p3 + p4) + \n    plot_annotation(\n      title = 'HDB Resale Market Dashboard (2020-2024)',\n      subtitle = 'An overview of price evolution, transaction volumes, price efficiency, and market share.',\n      caption = 'Source: Team 16 Analysis of data.gov.sg',\n      theme = theme(\n        plot.title = element_text(face = \"bold\", size = 22, hjust = 0.5),\n        plot.subtitle = element_text(size = 14, hjust = 0.5, color=\"grey40\"),\n        plot.caption = element_text(size=10, color=\"grey50\")\n      )\n    )\n) & \n  theme(legend.position = \"bottom\", legend.box = \"horizontal\")"
  },
  {
    "objectID": "HDB Resale Analysis and Visualization.html#introduction",
    "href": "HDB Resale Analysis and Visualization.html#introduction",
    "title": "HDB Resale Trends: Analysis and Enhanced Visualization",
    "section": "",
    "text": "This document validates our cleaned data against the original Straits Times article, reconstructs the article’s visualizations, and presents three new, improved charts to uncover deeper insights into the HDB resale market from 2020-2024.\n\n\n\nThis first step loads the necessary libraries and reads the clean CSV files that were created by our data_cleaning.qmd script.\n\n# --- 1. Setup and Load All Data ---\n\n# List of required packages for analysis and visualization\npackages &lt;- c(\"tidyverse\", \"lubridate\", \"scales\", \"forcats\", \"ggridges\", \"plotly\", \"sf\",\"patchwork\")\n\n# Loop through each package\nfor (pkg in packages) {\n  # Install the package if it's not already installed\n  if (!require(pkg, character.only = TRUE)) {\n    install.packages(pkg)\n  }\n  # Load the package\n  library(pkg, character.only = TRUE)\n}\n\n# Set global options for cleaner output\noptions(scipen = 999)\noptions(dplyr.summarise.inform = FALSE)\n\n# --- Load the CLEAN datasets from the previous script ---\n# Make sure these files are in a \"data_output\" subfolder.\nproject_data &lt;- read_csv(\"data_output/cleaned_hdb_resale_data.csv\")\npercentage_change &lt;- read_csv(\"data_output/percentage_change_analysis.csv\")\n\n# Confirm that data is loaded\ncat(\"Clean data loaded successfully. project_data has\", nrow(project_data), \"rows.\\n\")\n\nClean data loaded successfully. project_data has 127606 rows.\n\n\n\n\n\n\nWe first check if our data matches the key statistics cited in the article. This confirms the quality of our data preparation.\n\n# --- Validation 1: Transaction Counts (Jan-Nov) ---\ntransaction_validation &lt;- project_data %&gt;%\n  filter(month(month) &lt;= 11) %&gt;%\n  filter(flat_type == \"2 ROOM\", year %in% c(2020, 2024)) %&gt;%\n  group_by(year) %&gt;%\n  summarise(transaction_count = n())\n\nprint(\"Validation - 2-Room Transaction Counts (Jan-Nov):\")\n\n[1] \"Validation - 2-Room Transaction Counts (Jan-Nov):\"\n\nprint(transaction_validation)\n\n# A tibble: 2 × 2\n   year transaction_count\n  &lt;dbl&gt;             &lt;int&gt;\n1  2020               386\n2  2024               731\n\ncat(\"Article cited 388 (2020) and 740 (2024).\\n\\n\")\n\nArticle cited 388 (2020) and 740 (2024).\n\n# --- Validation 2 & 3: Median Prices (Q4) ---\nprice_validation &lt;- project_data %&gt;%\n  filter(quarter(month, with_year = FALSE) == 4) %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\"), year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(median_price = median(resale_price, na.rm = TRUE)) %&gt;%\n  arrange(flat_type, year)\n\nprint(\"Validation - Median Prices in Q4:\")\n\n[1] \"Validation - Median Prices in Q4:\"\n\nprint(price_validation)\n\n# A tibble: 4 × 3\n# Groups:   flat_type [2]\n  flat_type  year median_price\n  &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 2 ROOM     2020       238000\n2 2 ROOM     2024       355000\n3 3 ROOM     2020       305000\n4 3 ROOM     2024       424000\n\ncat(\"Article cited $238k/$353k for 2-room and $308k/$430k for 3-room.\\n\")\n\nArticle cited $238k/$353k for 2-room and $308k/$430k for 3-room.\n\n\n\n\n\n\nUsing our validated data, we recreate the two simple bar charts from the news article for direct comparison.\n\n\n\nggplot(percentage_change, \n       aes(x = percentage_change, \n           y = fct_reorder(flat_type_label, percentage_change))) +\n  geom_col(aes(fill = percentage_change &gt; 0), show.legend = FALSE) +\n  geom_text(aes(label = paste0(percentage_change, \"%\")), hjust = -0.15, size = 3.5, color = \"black\") +\n  scale_fill_manual(values = c(\"TRUE\" = \"#5D9CEC\", \"FALSE\" = \"#D9D9D9\")) +\n  scale_x_continuous(limits = c(-30, 100), breaks = seq(-30, 90, 10)) +\n  labs(\n    title = \"Recreation: Percentage Change in HDB Transactions\",\n    subtitle = \"From 2020 to 2024, based on our prepared data\",\n    x = NULL, y = NULL, caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), plot.title.position = \"plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n# Prepare data for the price change chart\nprice_change_summary &lt;- project_data %&gt;%\n  filter(year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(median_price = median(resale_price, na.rm = TRUE), .groups = \"drop\") %&gt;%\n  complete(flat_type, year = c(2020, 2024), fill = list(median_price = 0)) %&gt;%\n  pivot_wider(names_from = year, values_from = median_price, names_prefix = \"year_\") %&gt;%\n  mutate(\n    price_change_pct = if_else(year_2020 &gt; 0, round(((year_2024 - year_2020) / year_2020) * 100, 1), NA_real_),\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  ) %&gt;%\n  filter(!is.na(price_change_pct))\n\n# Recreate the price change chart\nggplot(price_change_summary, \n       aes(x = price_change_pct, \n           y = fct_reorder(flat_type_label, price_change_pct))) +\n  geom_col(aes(fill = flat_type %in% c(\"2 ROOM\", \"3 ROOM\")), show.legend = FALSE) +\n  geom_text(aes(label = paste0(price_change_pct, \"%\")), hjust = -0.15, size = 3.5, color = \"black\") +\n  scale_fill_manual(values = c(\"TRUE\" = \"#5D9CEC\", \"FALSE\" = \"#D9D9D9\")) +\n  scale_x_continuous(limits = c(0, 50), breaks = seq(0, 90, 10)) +\n  labs(\n    title = \"Recreation: Percentage Change in Resale Price\",\n    subtitle = \"From 2020 to 2024, based on our prepared data\",\n    x = NULL, y = NULL, caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), plot.title.position = \"plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe original charts are simple bar charts. We can create far more insightful and visually appealing charts by exploring distributions, trends over time, and spatial patterns in the data.\n\n\nA ridgeline plot shows the full range of prices, not just a single number. This reveals the significant overlap in prices between different flat types.\n\nif (!require(\"ggridges\")) {\n  install.packages(\"ggridges\")\n}\nlibrary(ggridges)\n\n# --- CORRECTED CODE ---\n# Prepare data with a clean label for plotting\nplot_data &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(\n    # Create the clean label (e.g., \"2 ROOM\" -&gt; \"2-Room\")\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  )\n\n# This ggplot call will now work correctly because `flat_type_label` exists\nggplot(plot_data, aes(x = resale_price, y = fct_rev(flat_type_label), fill = flat_type_label)) +\n  geom_density_ridges(alpha = 0.8, scale = 1.5) +\n  scale_x_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = \"k\")) +\n  labs(\n    title = \"Improved Viz: Price Distribution Varies Significantly by Flat Type\",\n    subtitle = \"Distribution of HDB resale prices from 2020-2024. Note the wide overlap.\",\n    x = \"Resale Price (S$)\",\n    y = NULL,\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title.position = \"plot\") \n\n\n\n\n\n\n\n\n\n\n\nA time series plot showing how prices evolved monthly, with smooth trend lines and confidence intervals.\n\n# Prepare monthly trend data\nmonthly_trends &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title(),\n    year_month = floor_date(month, \"month\")\n  ) %&gt;%\n  group_by(year_month, flat_type_label) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    q25 = quantile(resale_price, 0.25, na.rm = TRUE),\n    q75 = quantile(resale_price, 0.75, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Create an elegant time series plot\nggplot(monthly_trends, aes(x = year_month, y = median_price, color = flat_type_label, fill = flat_type_label)) +\n  geom_ribbon(aes(ymin = q25, ymax = q75), alpha = 0.2, color = NA) +\n  geom_line(size = 1.2, alpha = 0.9) +\n  geom_point(size = 1.5, alpha = 0.8) +\n  scale_x_date(\n    date_labels = \"%Y-%m\",\n    date_breaks = \"6 months\",\n    expand = c(0.02, 0.02)\n  ) +\n  scale_y_continuous(\n    labels = scales::dollar_format(scale = 1e-3, suffix = \"K\"),\n    breaks = scales::pretty_breaks(n = 6)\n  ) +\n  scale_color_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(\n    title = \"HDB Resale Price Trends Over Time\",\n    subtitle = \"Monthly median prices with interquartile ranges (ribbons) showing market volatility\",\n    x = \"Year-Month\",\n    y = \"Median Resale Price (S$)\",\n    color = \"Flat Type\",\n    fill = \"Flat Type\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.margin = margin(20, 20, 20, 20)\n  ) +\n  guides(\n    color = guide_legend(override.aes = list(size = 3)),\n    fill = guide_legend(override.aes = list(alpha = 0.3))\n  )\n\n\n\n\n\n\n\n\n\n\n\nA modern scatter plot with trend lines and marginal distributions showing the relationship between floor height and price efficiency.\n\n# Prepare data for storey analysis\nstorey_analysis &lt;- project_data %&gt;%\n  filter(\n    flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\"),\n    storey_mid &lt;= 50, # Remove extreme outliers\n    price_per_sqm &gt; 0 & price_per_sqm &lt; 15000 # Remove price outliers\n  ) %&gt;%\n  mutate(\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title(),\n    storey_group = case_when(\n      storey_mid &lt;= 5 ~ \"Low (1-5)\",\n      storey_mid &lt;= 10 ~ \"Mid-Low (6-10)\",\n      storey_mid &lt;= 15 ~ \"Mid (11-15)\",\n      storey_mid &lt;= 20 ~ \"Mid-High (16-20)\",\n      TRUE ~ \"High (21+)\"\n    ),\n    storey_group = factor(storey_group, levels = c(\"Low (1-5)\", \"Mid-Low (6-10)\", \"Mid (11-15)\", \"Mid-High (16-20)\", \"High (21+)\"))\n  )\n\n# Create an enhanced box plot for clearer trend analysis\nggplot(storey_analysis, \n       aes(x = storey_group, y = price_per_sqm, fill = storey_group)) +\n  geom_boxplot(alpha = 0.8, outlier.shape = NA) + # Hiding outliers for clarity\n  scale_y_continuous(\n    labels = scales::dollar_format(prefix = \"S$\"),\n    limits = quantile(storey_analysis$price_per_sqm, c(0.01, 0.99), na.rm = TRUE) # Zoom in\n  ) +\n  scale_fill_viridis_d(option = \"cividis\", guide = \"none\") +\n  facet_wrap(~flat_type_label, scales = \"free_y\", ncol = 3) +\n  labs(\n    title = \"Price per Sqm Distribution by Storey Height\",\n    subtitle = \"Box plots clearly show increasing price efficiency with height, faceted by flat type\",\n    x = \"Storey Group\",\n    y = \"Price per Square Meter (S$)\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    panel.grid.minor = element_blank(),\n    strip.text = element_text(face = \"bold\", size = 11),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.margin = margin(20, 20, 20, 20)\n  )\n\n\n\n\n\n\n\n\n\n\n\nA modern horizontal bar chart showing median prices by town, with interactive tooltips when rendered in HTML.\n\n# Prepare town-wise analysis\ntown_analysis &lt;- project_data %&gt;%\n  group_by(town) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    transaction_count = n(),\n    .groups = \"drop\"\n  ) %&gt;%\n  filter(transaction_count &gt;= 50) %&gt;% # Only include towns with sufficient data\n  arrange(desc(median_price)) %&gt;%\n  mutate(\n    town_rank = row_number(),\n    price_category = case_when(\n      median_price &gt;= 600000 ~ \"Premium (≥S$600K)\",\n      median_price &gt;= 450000 ~ \"High (S$450K-600K)\",\n      median_price &gt;= 350000 ~ \"Mid (S$350K-450K)\",\n      TRUE ~ \"Affordable (&lt;S$350K)\"\n    ),\n    price_category = factor(price_category, levels = c(\"Premium (≥S$600K)\", \"High (S$450K-600K)\", \"Mid (S$350K-450K)\", \"Affordable (&lt;S$350K)\"))\n  ) %&gt;%\n  slice_head(n = 20) # Show top 20 towns\n\n# Step 1: Create the ggplot object with a 'text' aesthetic for the tooltip\np_towns &lt;- ggplot(town_analysis, \n                  aes(x = median_price, y = fct_reorder(town, median_price), fill = price_category,\n                      # Define the custom tooltip content here\n                      text = paste(\"Town:\", town, \n                                   \"\\nMedian Price:\", scales::dollar(median_price),\n                                   \"\\nMedian PSM:\", scales::dollar(median_psm),\n                                   \"\\nTransactions:\", transaction_count))) +\n  geom_col(alpha = 0.8, width = 0.7) +\n  scale_x_continuous(\n    labels = scales::dollar_format(scale = 1e-3, suffix = \"K\"),\n    expand = expansion(mult = c(0, 0.15)) # Make space for labels/tooltips\n  ) +\n  scale_fill_manual(values = c(\n    \"Premium (≥S$600K)\" = \"#E31A1C\",\n    \"High (S$450K-600K)\" = \"#FF7F00\", \n    \"Mid (S$350K-450K)\" = \"#1F78B4\",\n    \"Affordable (&lt;S$350K)\" = \"#33A02C\"\n  )) +\n  labs(\n    title = \"Interactive Top 20 HDB Towns by Median Resale Price\",\n    subtitle = \"Ranked by median price (2020-2024). Hover on bars for details.\",\n    x = \"Median Resale Price (S$)\",\n    y = NULL,\n    fill = \"Price Category\",\n    caption = \"Source: Team 16 Analysis of data.gov.sg\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", size = 11),\n    legend.position = \"bottom\",\n    panel.grid.major.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"),\n    plot.margin = margin(20, 20, 20, 20)\n  )\n\n# Step 2: Convert the ggplot object to an interactive plotly chart\nplotly::ggplotly(p_towns, tooltip = \"text\")\n\n\n\n\n\n\n\n\nThis multi-panel dashboard, built with the patchwork package, provides a powerful, at-a-glance summary of the HDB resale market, combining price trends, transaction volumes, and market share into a single, cohesive view.\n\n# Prepare summary statistics for the dashboard\nsummary_stats &lt;- project_data %&gt;%\n  filter(flat_type %in% c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")) %&gt;%\n  mutate(flat_type_label = str_replace(flat_type, \" ROOM\", \"-Room\") %&gt;% str_to_title()) %&gt;%\n  group_by(flat_type_label, year) %&gt;%\n  summarise(\n    median_price = median(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    transaction_count = n(),\n    .groups = \"drop\"\n  )\n\n# Panel 1: Price evolution by year\np1 &lt;- ggplot(summary_stats, aes(x = year, y = median_price, color = flat_type_label)) +\n  geom_line(size = 1.2, alpha = 0.9) +\n  geom_point(size = 2) +\n  scale_x_continuous(breaks = 2020:2024) +\n  scale_y_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = \"K\")) +\n  scale_color_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(title = \"A. Price Evolution by Year\", x = NULL, y = \"Median Price\", color = \"Flat Type\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), legend.title = element_text(face=\"bold\"))\n\n# Panel 2: Transaction volume by year\np2 &lt;- ggplot(summary_stats, aes(x = year, y = transaction_count, fill = flat_type_label)) +\n  geom_col(position = \"stack\", alpha = 0.8) +\n  scale_x_continuous(breaks = 2020:2024) +\n  scale_y_continuous(labels = scales::comma) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9) +\n  labs(title = \"B. Transaction Volume by Year\", x = NULL, y = \"Transactions\", fill = \"Flat Type\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), legend.title = element_text(face=\"bold\"))\n\n# Panel 3: Price per sqm comparison\np3 &lt;- ggplot(summary_stats %&gt;% filter(year %in% c(2020, 2024)), \n             aes(x = fct_reorder(flat_type_label, median_psm), y = median_psm, fill = factor(year))) +\n  geom_col(position = \"dodge\", alpha = 0.8) +\n  scale_y_continuous(labels = scales::dollar_format(prefix = \"S$\")) +\n  scale_fill_manual(values = c(\"2020\" = \"#440154FF\", \"2024\" = \"#FDE725FF\"), name = \"Year\") +\n  labs(title = \"C. Price per Sqm: 2020 vs 2024\", x = NULL, y = \"Median PSM\") +\n  theme_minimal(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\"), axis.text.x = element_text(angle=45, hjust=1), legend.title = element_text(face=\"bold\"))\n\n# Panel 4: Market share by flat type in the last full year\n# We use 2023 for a full year's data, as 2024 is incomplete.\nmarket_share &lt;- summary_stats %&gt;%\n  group_by(year) %&gt;%\n  mutate(market_share = transaction_count / sum(transaction_count)) %&gt;%\n  ungroup() %&gt;%\n  filter(year == 2023)\n\np4 &lt;- ggplot(market_share, aes(x = \"\", y = market_share, fill = fct_reorder(flat_type_label, market_share))) +\n  geom_col(width = 1, alpha = 0.8) +\n  coord_polar(\"y\", start = 0) +\n  geom_text(aes(label = scales::percent(market_share, accuracy = 1)), \n            position = position_stack(vjust = 0.5), color = \"white\", fontface = \"bold\") +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.1, end = 0.9, guide=\"none\") +\n  labs(title = \"D. Market Share by Flat Type (2023)\") +\n  theme_void(base_size = 12) +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n# --- FIX IS HERE ---\n# Combine all panels using patchwork.\n# We wrap the main plot composition in parentheses to ensure it's evaluated\n# fully before the `&` operator is applied. This resolves the precedence issue.\n(\n  (p1 + p2) / (p3 + p4) + \n    plot_annotation(\n      title = 'HDB Resale Market Dashboard (2020-2024)',\n      subtitle = 'An overview of price evolution, transaction volumes, price efficiency, and market share.',\n      caption = 'Source: Team 16 Analysis of data.gov.sg',\n      theme = theme(\n        plot.title = element_text(face = \"bold\", size = 22, hjust = 0.5),\n        plot.subtitle = element_text(size = 14, hjust = 0.5, color=\"grey40\"),\n        plot.caption = element_text(size=10, color=\"grey50\")\n      )\n    )\n) & \n  theme(legend.position = \"bottom\", legend.box = \"horizontal\")"
  },
  {
    "objectID": "Jiarui.html",
    "href": "Jiarui.html",
    "title": "Jiarui",
    "section": "",
    "text": "library(plotly)\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ lubridate 1.9.4     ✔ tibble    3.2.1\n✔ purrr     1.0.4     ✔ tidyr     1.3.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks plotly::filter(), stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n# Load data\nsummary_data &lt;- read_csv('data_output/summary_by_type_year.csv') %&gt;% mutate(flat_type = as.factor(flat_type))\n\nRows: 35 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): flat_type\ndbl (5): year, transaction_count, median_price, mean_price, median_psm\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntypes &lt;- levels(summary_data$flat_type)\n\ntotal_by_year &lt;- summary_data %&gt;% group_by(year) %&gt;% summarise(total = sum(transaction_count))\n\nbar_traces &lt;- list()\nfor (i in seq_along(types)) {\n  type &lt;- types[i]\n  df &lt;- summary_data %&gt;% filter(flat_type == type)\n  bar_traces[[i]] &lt;- list(\n    x = as.character(df$year),\n    y = df$transaction_count,\n    name = paste(type, \"Volume\"),\n    type = 'bar',\n    marker = list(opacity = 0.7),\n    visible = TRUE\n    # (market share text and hovertemplate removed)\n  )\n}\n\n# Line traces for median price\nline_traces &lt;- lapply(seq_along(types), function(i) {\n  type &lt;- types[i]\n  df &lt;- summary_data %&gt;% filter(flat_type == type)\n  list(\n    x = as.character(df$year),\n    y = df$median_price,\n    name = paste(type, \"Median Price\"),\n    yaxis = 'y2',\n    type = 'scatter',\n    mode = 'lines+markers',\n    line = list(width = 3),\n    visible = TRUE\n  )\n})\n\nall_traces &lt;- c(bar_traces, line_traces)\n\nfig &lt;- plot_ly()\nfor (trace in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    x = trace$x,\n    y = trace$y,\n    name = trace$name,\n    type = trace$type,\n    marker = trace$marker,\n    yaxis = trace$yaxis,\n    mode = trace$mode,\n    line = trace$line,\n    visible = trace$visible\n    # (text, textposition, textfont, hovertemplate all removed)\n  )\n}\n\nupdatemenus = list(list(\n  active = 0,\n  buttons = c(\n    list(\n      list(\n        method = 'update',\n        args = list(list(visible = rep(TRUE, 2 * length(types)))),\n        label = 'Show All'\n      )\n    ),\n    lapply(seq_along(types), function(i) {\n      vis &lt;- rep(FALSE, 2 * length(types))\n      vis[i] &lt;- TRUE\n      vis[i + length(types)] &lt;- TRUE\n      list(\n        method = \"update\",\n        args = list(list(visible = vis)),\n        label = types[i]\n      )\n    })\n  ),\n  direction = \"down\",\n  x = 1.08,\n  y = 1.05\n))\n\nfig &lt;- fig %&gt;% layout(\n  title = \"HDB Resale Volume and Price Evolution by Year\",\n  xaxis = list(title = \"Year\"),\n  yaxis = list(title = \"Number of Transactions\", rangemode = 'tozero'),\n  yaxis2 = list(title = \"Median Resale Price\", overlaying = \"y\", side = \"right\", rangemode = 'tozero'),\n  updatemenus = updatemenus,\n  legend = list(orientation = 'h', y = -0.2)\n)\n\nfig &lt;- fig %&gt;% config(displayModeBar = FALSE)\n\nfig\n\n\n\n\n\n\n# 1. volume bars (stacked)\nvol_fig &lt;- plot_ly() %&gt;% \n  add_bars(data = summary_data, x = ~year, y = ~transaction_count,\n           color = ~flat_type, legendgroup = ~flat_type,\n           hovertemplate = \"Year %{x}&lt;br&gt;%{y} transactions&lt;extra&gt;&lt;/extra&gt;\") %&gt;% \n  layout(barmode = \"stack\",\n         yaxis = list(title = \"Transactions\"),\n         showlegend = FALSE)\n\n# 2. price lines\nprice_fig &lt;- plot_ly() %&gt;% \n  add_lines(data = summary_data, x = ~year, y = ~median_price,\n            color = ~flat_type, legendgroup = ~flat_type,\n            line = list(width = 2),\n            hovertemplate = \"Year %{x}&lt;br&gt;$%{y:,.0f}&lt;extra&gt;&lt;/extra&gt;\") %&gt;% \n  layout(yaxis = list(title = \"Median Price\", tickprefix = \"$\"))\n\n# 3. combine\nsubplot(vol_fig, price_fig, nrows = 2, shareX = TRUE, heights = c(.58,.42)) %&gt;%\n  layout(title = \"HDB Resale Volume & Price Evolution (2020-2024)\",\n         legend = list(orientation = 'h', y = -0.1)) %&gt;% \n  config(displayModeBar = FALSE)"
  },
  {
    "objectID": "HDB Resale Data Cleaning and Transformation.html",
    "href": "HDB Resale Data Cleaning and Transformation.html",
    "title": "HDB Resale Data Cleaning and Transformation",
    "section": "",
    "text": "This document outlines the enhanced data cleaning and transformation process for analyzing HDB resale flat transactions. It builds upon the original script by incorporating a more dynamic approach to outlier handling for better reproducibility.\n\n\nThis chunk checks if each package is installed before loading it. If a package is missing, it will be automatically installed.\n\n# This chunk checks if each package is installed. If not, it installs it.\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif (!require(\"lubridate\")) install.packages(\"lubridate\")\nif (!require(\"readr\")) install.packages(\"readr\")\nif (!require(\"naniar\")) install.packages(\"naniar\")\nif (!require(\"visdat\")) install.packages(\"visdat\")\nif (!require(\"stringr\")) install.packages(\"stringr\")\nif (!require(\"janitor\")) install.packages(\"janitor\") # This line fixes the error\nif (!require(\"scales\")) install.packages(\"scales\")\n\n# Load all required libraries\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readr)\nlibrary(naniar)\nlibrary(visdat)\nlibrary(stringr)\nlibrary(janitor)\nlibrary(scales)\n\n# Set options for better output\noptions(scipen = 999)  # Disable scientific notation\noptions(dplyr.summarise.inform = FALSE) # Suppress summarise messages\n\n\n\n\nThis section loads and combines the multiple HDB resale data CSV files into a single dataframe.\n\n# Function to load and combine multiple CSV files\nload_hdb_data &lt;- function(file_paths) {\n  # We explicitly tell read_csv to treat 'remaining_lease' as a character column\n  # for all files to prevent type conflicts.\n  combined_data &lt;- file_paths %&gt;%\n    map_dfr(~ read_csv(.x, \n                       col_types = cols(remaining_lease = col_character()), \n                       show_col_types = FALSE)) %&gt;%\n    distinct()  # Remove any duplicate rows\n  \n  return(combined_data)\n}\n\n# Define the paths to your files\nfile_paths &lt;- c(\n  \"2020-2025.csv\"\n)\n\n# Load and combine data\nraw_data &lt;- load_hdb_data(file_paths)\nraw_data &lt;- janitor::clean_names(raw_data)\n\n# Initial inspection\ncat(\"Dataset dimensions:\", dim(raw_data), \"\\n\")\n\nDataset dimensions: 146524 11 \n\nglimpse(raw_data)\n\nRows: 146,524\nColumns: 11\n$ month               &lt;chr&gt; \"2020-01\", \"2020-01\", \"2020-01\", \"2020-01\", \"2020-…\n$ town                &lt;chr&gt; \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO …\n$ flat_type           &lt;chr&gt; \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", …\n$ block               &lt;chr&gt; \"208\", \"307C\", \"319\", \"216\", \"556\", \"536\", \"560\", …\n$ street_name         &lt;chr&gt; \"ANG MO KIO AVE 1\", \"ANG MO KIO AVE 1\", \"ANG MO KI…\n$ storey_range        &lt;chr&gt; \"04 TO 06\", \"19 TO 21\", \"01 TO 03\", \"04 TO 06\", \"0…\n$ floor_area_sqm      &lt;dbl&gt; 73, 70, 73, 73, 68, 68, 67, 82, 67, 67, 67, 67, 67…\n$ flat_model          &lt;chr&gt; \"New Generation\", \"Model A\", \"New Generation\", \"Ne…\n$ lease_commence_date &lt;dbl&gt; 1976, 2012, 1977, 1976, 1980, 1980, 1980, 1980, 19…\n$ remaining_lease     &lt;chr&gt; \"55 years 07 months\", \"91 years 08 months\", \"56 ye…\n$ resale_price        &lt;dbl&gt; 265000, 470000, 230000, 280000, 220000, 280000, 24…\n\n\n\n\n\nHere, we visualize and quantify missing data, then remove rows where critical information is missing.\n\n# First, create a smaller, random sample of the data for visualization.\ndata_sample_for_vis &lt;- slice_sample(raw_data, n = 80000)\n\n# Now, visualize the missing patterns on the SMALL sample. This will now work.\nvis_miss(data_sample_for_vis)\n\n\n\n\n\n\n\n# Remove rows with missing critical information from the FULL raw_data dataframe.\ncleaned_data &lt;- raw_data %&gt;%\n  drop_na(resale_price, floor_area_sqm, month, town, flat_type)\n\ncat(\"Rows removed due to missing critical data:\", nrow(raw_data) - nrow(cleaned_data), \"\\n\")\n\nRows removed due to missing critical data: 0 \n\ncat(\"Remaining rows:\", nrow(cleaned_data), \"\\n\")\n\nRemaining rows: 146524 \n\n\n\n\n\nWe convert columns to their appropriate data types and standardize text formats for consistency.\n\nprocessed_data &lt;- cleaned_data %&gt;%\n  mutate(\n    # Convert month to proper Date format\n    month = ym(month),\n    \n    # Ensure numeric columns are properly formatted\n    resale_price = as.numeric(resale_price),\n    floor_area_sqm = as.numeric(floor_area_sqm),\n    \n    # Standardize text columns (e.g., trim whitespace, convert to consistent case)\n    town = str_to_upper(str_trim(town)),\n    flat_type = str_to_upper(str_trim(flat_type)),\n    flat_model = str_to_upper(str_trim(flat_model)),\n    street_name = str_to_title(str_trim(street_name))\n  )\n\ncat(\"Date range:\", as.character(min(processed_data$month)), \"to\", as.character(max(processed_data$month)), \"\\n\")\n\nDate range: 2020-01-01 to 2025-07-01 \n\n\n\n\n\nWe create several new, informative variables to support our analysis.\n\nengineered_data &lt;- processed_data %&gt;%\n  mutate(\n    # Extract temporal features\n    year = year(month),\n    quarter = quarter(month, with_year = TRUE),\n    \n    # Calculate price per square meter\n    price_per_sqm = round(resale_price / floor_area_sqm, 2),\n    \n    # Extract storey information and create a numeric midpoint\n    storey_mid = sapply(str_split(storey_range, \" TO \"), function(x) mean(as.numeric(x))),\n    \n    # Categorize flat types for broader analysis\n    flat_category = case_when(\n      flat_type %in% c(\"1 ROOM\", \"2 ROOM\") ~ \"Small (1-2 Room)\",\n      flat_type == \"3 ROOM\" ~ \"Medium (3 Room)\",\n      flat_type %in% c(\"4 ROOM\", \"5 ROOM\") ~ \"Large (4-5 Room)\",\n      TRUE ~ \"Others\"\n    )\n  )\n\ncat(\"New variables created successfully!\\n\")\n\nNew variables created successfully!\n\nglimpse(engineered_data)\n\nRows: 146,524\nColumns: 16\n$ month               &lt;date&gt; 2020-01-01, 2020-01-01, 2020-01-01, 2020-01-01, 2…\n$ town                &lt;chr&gt; \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO …\n$ flat_type           &lt;chr&gt; \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", …\n$ block               &lt;chr&gt; \"208\", \"307C\", \"319\", \"216\", \"556\", \"536\", \"560\", …\n$ street_name         &lt;chr&gt; \"Ang Mo Kio Ave 1\", \"Ang Mo Kio Ave 1\", \"Ang Mo Ki…\n$ storey_range        &lt;chr&gt; \"04 TO 06\", \"19 TO 21\", \"01 TO 03\", \"04 TO 06\", \"0…\n$ floor_area_sqm      &lt;dbl&gt; 73, 70, 73, 73, 68, 68, 67, 82, 67, 67, 67, 67, 67…\n$ flat_model          &lt;chr&gt; \"NEW GENERATION\", \"MODEL A\", \"NEW GENERATION\", \"NE…\n$ lease_commence_date &lt;dbl&gt; 1976, 2012, 1977, 1976, 1980, 1980, 1980, 1980, 19…\n$ remaining_lease     &lt;chr&gt; \"55 years 07 months\", \"91 years 08 months\", \"56 ye…\n$ resale_price        &lt;dbl&gt; 265000, 470000, 230000, 280000, 220000, 280000, 24…\n$ year                &lt;dbl&gt; 2020, 2020, 2020, 2020, 2020, 2020, 2020, 2020, 20…\n$ quarter             &lt;dbl&gt; 2020.1, 2020.1, 2020.1, 2020.1, 2020.1, 2020.1, 20…\n$ price_per_sqm       &lt;dbl&gt; 3630.14, 6714.29, 3150.68, 3835.62, 3235.29, 4117.…\n$ storey_mid          &lt;dbl&gt; 5, 20, 2, 5, 8, 11, 5, 5, 2, 2, 8, 5, 2, 5, 2, 8, …\n$ flat_category       &lt;chr&gt; \"Medium (3 Room)\", \"Medium (3 Room)\", \"Medium (3 R…\n\n\n\n\n\nInstead of using fixed values, we calculate outlier boundaries dynamically using the IQR method for each flat type. This makes our analysis more robust and reproducible.\n\n# Calculate the lower and upper bounds for resale_price for each flat type\noutlier_bounds &lt;- engineered_data %&gt;%\n  group_by(flat_type) %&gt;%\n  summarise(\n    lower_bound = quantile(resale_price, 0.25, na.rm = TRUE) - 1.5 * IQR(resale_price, na.rm = TRUE),\n    upper_bound = quantile(resale_price, 0.75, na.rm = TRUE) + 1.5 * IQR(resale_price, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nprint(\"Calculated outlier bounds for resale price:\")\n\n[1] \"Calculated outlier bounds for resale price:\"\n\nprint(outlier_bounds)\n\n# A tibble: 7 × 3\n  flat_type        lower_bound upper_bound\n  &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;\n1 1 ROOM                137500      309500\n2 2 ROOM                150000      470000\n3 3 ROOM                165000      597000\n4 4 ROOM                215000      863000\n5 5 ROOM                267500     1007500\n6 EXECUTIVE             352500     1172500\n7 MULTI-GENERATION      507875     1242875\n\n# Sanity check for unrealistic values in the dataset\nquality_check &lt;- engineered_data %&gt;%\n  summarise(\n    negative_prices = sum(resale_price &lt; 0, na.rm = TRUE),\n    zero_areas = sum(floor_area_sqm &lt;= 0, na.rm = TRUE)\n  )\n\nprint(\"Data quality summary:\")\n\n[1] \"Data quality summary:\"\n\nprint(quality_check)\n\n# A tibble: 1 × 2\n  negative_prices zero_areas\n            &lt;int&gt;      &lt;int&gt;\n1               0          0\n\n\n\n\n\nWe filter the data for our project’s focus period (2020-2024) and remove outliers based on the dynamic bounds calculated in the previous step.\n\n# Join the outlier bounds to the main dataset and then filter\nproject_data &lt;- engineered_data %&gt;%\n  left_join(outlier_bounds, by = \"flat_type\") %&gt;%\n  filter(\n    # Filter for the project's time period\n    year &gt;= 2020 & year &lt;= 2024,\n    \n    # Dynamic outlier removal for price based on flat type\n    resale_price &gt;= lower_bound & resale_price &lt;= upper_bound,\n    \n    # Apply additional reasonable sanity checks\n    floor_area_sqm &gt; 20 & floor_area_sqm &lt; 250,\n    price_per_sqm &gt; 1000 & price_per_sqm &lt; 20000\n  ) %&gt;%\n  # Remove the temporary bound columns\n  select(-lower_bound, -upper_bound)\n\ncat(\"Final dataset dimensions after filtering:\", dim(project_data), \"\\n\")\n\nFinal dataset dimensions after filtering: 127606 16 \n\ncat(\"Years covered:\", paste(sort(unique(project_data$year)), collapse = \", \"), \"\\n\")\n\nYears covered: 2020, 2021, 2022, 2023, 2024 \n\n\n\n\n\nWe now create a summary table based on our clean, project-focused data.\n\nsummary_by_type_year &lt;- project_data %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(\n    transaction_count = n(),\n    median_price = median(resale_price, na.rm = TRUE),\n    mean_price = mean(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Display summary for key flat types\nkey_flat_types &lt;- c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")\nsummary_by_type_year %&gt;%\n  filter(flat_type %in% key_flat_types) %&gt;%\n  arrange(flat_type, year) %&gt;%\n  print(n = 25)\n\n# A tibble: 25 × 6\n   flat_type  year transaction_count median_price mean_price median_psm\n   &lt;chr&gt;     &lt;dbl&gt;             &lt;int&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 2 ROOM     2020               416       230000    233388.      5000 \n 2 2 ROOM     2021               382       265000    265938.      5745.\n 3 2 ROOM     2022               453       300000    295959.      6508.\n 4 2 ROOM     2023               681       320000    319504.      7021.\n 5 2 ROOM     2024               789       340000    339216.      7462.\n 6 3 ROOM     2020              5290       293000    306721.      4283.\n 7 3 ROOM     2021              6089       332000    344126.      4853.\n 8 3 ROOM     2022              6066       366000    376550.      5342.\n 9 3 ROOM     2023              6008       388000    396463.      5649.\n10 3 ROOM     2024              6302       410000    418791.      5976.\n11 4 ROOM     2020              9540       420000    443709.      4418.\n12 4 ROOM     2021             12080       468000    496212.      4969.\n13 4 ROOM     2022             10806       510000    531472.      5380.\n14 4 ROOM     2023             10692       541000    561019.      5714.\n15 4 ROOM     2024             10894       580000    591567.      6087.\n16 5 ROOM     2020              5927       506000    536509.      4274.\n17 5 ROOM     2021              7652       565944    594047.      4792.\n18 5 ROOM     2022              6504       615000    639271.      5180.\n19 5 ROOM     2023              5657       645000    669595.      5445.\n20 5 ROOM     2024              6100       680000    702131.      5771.\n21 EXECUTIVE  2020              1882       618000    635395.      4256.\n22 EXECUTIVE  2021              2256       690000    704865.      4762.\n23 EXECUTIVE  2022              1865       760000    777138.      5241.\n24 EXECUTIVE  2023              1482       810000    823433.      5594.\n25 EXECUTIVE  2024              1700       850000    859210.      5877.\n\n\n\n\n\nTo replicate and critique the original visualization, we calculate the percentage change in transactions from 2020 to 2024. We also create a flat_type_label for cleaner plotting.\n\npercentage_change &lt;- project_data %&gt;%\n  filter(year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(transaction_count = n(), .groups = \"drop\") %&gt;%\n  \n  complete(flat_type, year = c(2020, 2024), fill = list(transaction_count = 0)) %&gt;%\n  \n  pivot_wider(names_from = year, \n              values_from = transaction_count, \n              names_prefix = \"year_\") %&gt;%\n  \n  mutate(\n    percentage_change = if_else(year_2020 &gt; 0, \n                                round(((year_2024 - year_2020) / year_2020) * 100, 1), \n                                NA_real_), # Set to NA if 2020 count is 0\n    absolute_change = year_2024 - year_2020,\n    # Create a clean label for plotting\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  ) %&gt;%\n  arrange(desc(percentage_change))\n\nprint(\"Percentage change in transactions (2020-2024):\")\n\n[1] \"Percentage change in transactions (2020-2024):\"\n\nprint(percentage_change)\n\n# A tibble: 7 × 6\n  flat_type        year_2020 year_2024 percentage_change absolute_change\n  &lt;chr&gt;                &lt;int&gt;     &lt;int&gt;             &lt;dbl&gt;           &lt;int&gt;\n1 2 ROOM                 416       789              89.7             373\n2 3 ROOM                5290      6302              19.1            1012\n3 4 ROOM                9540     10894              14.2            1354\n4 1 ROOM                  10        11              10                 1\n5 5 ROOM                5927      6100               2.9             173\n6 EXECUTIVE             1882      1700              -9.7            -182\n7 MULTI-GENERATION         8         6             -25                -2\n# ℹ 1 more variable: flat_type_label &lt;chr&gt;\n\n\n\n\n\nWe save the cleaned data and summary tables to CSV files for use in our visualization tools and final report.\n\n# Create a 'data_output' directory if it doesn't exist\nif (!dir.exists(\"data_output\")) {\n  dir.create(\"data_output\")\n}\n\n# Save the final datasets\nwrite_csv(project_data, \"data_output/cleaned_hdb_resale_data.csv\")\nwrite_csv(summary_by_type_year, \"data_output/summary_by_type_year.csv\")\nwrite_csv(percentage_change, \"data_output/percentage_change_analysis.csv\")\n\ncat(\"Data cleaning completed successfully!\\n\")\n\nData cleaning completed successfully!\n\ncat(\"Files saved in 'data_output/' directory.\\n\")\n\nFiles saved in 'data_output/' directory.\n\n\n\n\n\nA final check to confirm the state of our prepared dataset.\n\nvalidation_summary &lt;- list(\n  total_records = nrow(project_data),\n  date_range = paste(min(project_data$month), \"to\", max(project_data$month)),\n  flat_types_count = length(unique(project_data$flat_type)),\n  towns_count = length(unique(project_data$town)),\n  years = sort(unique(project_data$year)),\n  price_range = paste0(\"$\", format(min(project_data$resale_price), big.mark = \",\"), \n                      \" to $\", format(max(project_data$resale_price), big.mark = \",\")),\n  missing_values_final = sum(is.na(project_data))\n)\n\ncat(\"=== DATA VALIDATION SUMMARY ===\\n\")\n\n=== DATA VALIDATION SUMMARY ===\n\ncat(\"Total records in final dataset:\", validation_summary$total_records, \"\\n\")\n\nTotal records in final dataset: 127606 \n\ncat(\"Date range:\", validation_summary$date_range, \"\\n\")\n\nDate range: 2020-01-01 to 2024-12-01 \n\ncat(\"Number of unique flat types:\", validation_summary$flat_types_count, \"\\n\")\n\nNumber of unique flat types: 7 \n\ncat(\"Number of unique towns:\", validation_summary$towns_count, \"\\n\")\n\nNumber of unique towns: 26 \n\ncat(\"Years covered:\", paste(validation_summary$years, collapse = \", \"), \"\\n\")\n\nYears covered: 2020, 2021, 2022, 2023, 2024 \n\ncat(\"Final price range:\", validation_summary$price_range, \"\\n\")\n\nFinal price range: $150,000 to $1,200,000 \n\ncat(\"Total missing values in final dataset:\", validation_summary$missing_values_final, \"\\n\")\n\nTotal missing values in final dataset: 0 \n\ncat(\"===============================\\n\")\n\n==============================="
  },
  {
    "objectID": "HDB Resale Data Cleaning and Transformation.html#aai1001---data-engineering-and-visualization-project",
    "href": "HDB Resale Data Cleaning and Transformation.html#aai1001---data-engineering-and-visualization-project",
    "title": "HDB Resale Data Cleaning and Transformation",
    "section": "",
    "text": "This document outlines the enhanced data cleaning and transformation process for analyzing HDB resale flat transactions. It builds upon the original script by incorporating a more dynamic approach to outlier handling for better reproducibility.\n\n\nThis chunk checks if each package is installed before loading it. If a package is missing, it will be automatically installed.\n\n# This chunk checks if each package is installed. If not, it installs it.\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif (!require(\"lubridate\")) install.packages(\"lubridate\")\nif (!require(\"readr\")) install.packages(\"readr\")\nif (!require(\"naniar\")) install.packages(\"naniar\")\nif (!require(\"visdat\")) install.packages(\"visdat\")\nif (!require(\"stringr\")) install.packages(\"stringr\")\nif (!require(\"janitor\")) install.packages(\"janitor\") # This line fixes the error\nif (!require(\"scales\")) install.packages(\"scales\")\n\n# Load all required libraries\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readr)\nlibrary(naniar)\nlibrary(visdat)\nlibrary(stringr)\nlibrary(janitor)\nlibrary(scales)\n\n# Set options for better output\noptions(scipen = 999)  # Disable scientific notation\noptions(dplyr.summarise.inform = FALSE) # Suppress summarise messages\n\n\n\n\nThis section loads and combines the multiple HDB resale data CSV files into a single dataframe.\n\n# Function to load and combine multiple CSV files\nload_hdb_data &lt;- function(file_paths) {\n  # We explicitly tell read_csv to treat 'remaining_lease' as a character column\n  # for all files to prevent type conflicts.\n  combined_data &lt;- file_paths %&gt;%\n    map_dfr(~ read_csv(.x, \n                       col_types = cols(remaining_lease = col_character()), \n                       show_col_types = FALSE)) %&gt;%\n    distinct()  # Remove any duplicate rows\n  \n  return(combined_data)\n}\n\n# Define the paths to your files\nfile_paths &lt;- c(\n  \"2020-2025.csv\"\n)\n\n# Load and combine data\nraw_data &lt;- load_hdb_data(file_paths)\nraw_data &lt;- janitor::clean_names(raw_data)\n\n# Initial inspection\ncat(\"Dataset dimensions:\", dim(raw_data), \"\\n\")\n\nDataset dimensions: 146524 11 \n\nglimpse(raw_data)\n\nRows: 146,524\nColumns: 11\n$ month               &lt;chr&gt; \"2020-01\", \"2020-01\", \"2020-01\", \"2020-01\", \"2020-…\n$ town                &lt;chr&gt; \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO …\n$ flat_type           &lt;chr&gt; \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", …\n$ block               &lt;chr&gt; \"208\", \"307C\", \"319\", \"216\", \"556\", \"536\", \"560\", …\n$ street_name         &lt;chr&gt; \"ANG MO KIO AVE 1\", \"ANG MO KIO AVE 1\", \"ANG MO KI…\n$ storey_range        &lt;chr&gt; \"04 TO 06\", \"19 TO 21\", \"01 TO 03\", \"04 TO 06\", \"0…\n$ floor_area_sqm      &lt;dbl&gt; 73, 70, 73, 73, 68, 68, 67, 82, 67, 67, 67, 67, 67…\n$ flat_model          &lt;chr&gt; \"New Generation\", \"Model A\", \"New Generation\", \"Ne…\n$ lease_commence_date &lt;dbl&gt; 1976, 2012, 1977, 1976, 1980, 1980, 1980, 1980, 19…\n$ remaining_lease     &lt;chr&gt; \"55 years 07 months\", \"91 years 08 months\", \"56 ye…\n$ resale_price        &lt;dbl&gt; 265000, 470000, 230000, 280000, 220000, 280000, 24…\n\n\n\n\n\nHere, we visualize and quantify missing data, then remove rows where critical information is missing.\n\n# First, create a smaller, random sample of the data for visualization.\ndata_sample_for_vis &lt;- slice_sample(raw_data, n = 80000)\n\n# Now, visualize the missing patterns on the SMALL sample. This will now work.\nvis_miss(data_sample_for_vis)\n\n\n\n\n\n\n\n# Remove rows with missing critical information from the FULL raw_data dataframe.\ncleaned_data &lt;- raw_data %&gt;%\n  drop_na(resale_price, floor_area_sqm, month, town, flat_type)\n\ncat(\"Rows removed due to missing critical data:\", nrow(raw_data) - nrow(cleaned_data), \"\\n\")\n\nRows removed due to missing critical data: 0 \n\ncat(\"Remaining rows:\", nrow(cleaned_data), \"\\n\")\n\nRemaining rows: 146524 \n\n\n\n\n\nWe convert columns to their appropriate data types and standardize text formats for consistency.\n\nprocessed_data &lt;- cleaned_data %&gt;%\n  mutate(\n    # Convert month to proper Date format\n    month = ym(month),\n    \n    # Ensure numeric columns are properly formatted\n    resale_price = as.numeric(resale_price),\n    floor_area_sqm = as.numeric(floor_area_sqm),\n    \n    # Standardize text columns (e.g., trim whitespace, convert to consistent case)\n    town = str_to_upper(str_trim(town)),\n    flat_type = str_to_upper(str_trim(flat_type)),\n    flat_model = str_to_upper(str_trim(flat_model)),\n    street_name = str_to_title(str_trim(street_name))\n  )\n\ncat(\"Date range:\", as.character(min(processed_data$month)), \"to\", as.character(max(processed_data$month)), \"\\n\")\n\nDate range: 2020-01-01 to 2025-07-01 \n\n\n\n\n\nWe create several new, informative variables to support our analysis.\n\nengineered_data &lt;- processed_data %&gt;%\n  mutate(\n    # Extract temporal features\n    year = year(month),\n    quarter = quarter(month, with_year = TRUE),\n    \n    # Calculate price per square meter\n    price_per_sqm = round(resale_price / floor_area_sqm, 2),\n    \n    # Extract storey information and create a numeric midpoint\n    storey_mid = sapply(str_split(storey_range, \" TO \"), function(x) mean(as.numeric(x))),\n    \n    # Categorize flat types for broader analysis\n    flat_category = case_when(\n      flat_type %in% c(\"1 ROOM\", \"2 ROOM\") ~ \"Small (1-2 Room)\",\n      flat_type == \"3 ROOM\" ~ \"Medium (3 Room)\",\n      flat_type %in% c(\"4 ROOM\", \"5 ROOM\") ~ \"Large (4-5 Room)\",\n      TRUE ~ \"Others\"\n    )\n  )\n\ncat(\"New variables created successfully!\\n\")\n\nNew variables created successfully!\n\nglimpse(engineered_data)\n\nRows: 146,524\nColumns: 16\n$ month               &lt;date&gt; 2020-01-01, 2020-01-01, 2020-01-01, 2020-01-01, 2…\n$ town                &lt;chr&gt; \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO KIO\", \"ANG MO …\n$ flat_type           &lt;chr&gt; \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", \"3 ROOM\", …\n$ block               &lt;chr&gt; \"208\", \"307C\", \"319\", \"216\", \"556\", \"536\", \"560\", …\n$ street_name         &lt;chr&gt; \"Ang Mo Kio Ave 1\", \"Ang Mo Kio Ave 1\", \"Ang Mo Ki…\n$ storey_range        &lt;chr&gt; \"04 TO 06\", \"19 TO 21\", \"01 TO 03\", \"04 TO 06\", \"0…\n$ floor_area_sqm      &lt;dbl&gt; 73, 70, 73, 73, 68, 68, 67, 82, 67, 67, 67, 67, 67…\n$ flat_model          &lt;chr&gt; \"NEW GENERATION\", \"MODEL A\", \"NEW GENERATION\", \"NE…\n$ lease_commence_date &lt;dbl&gt; 1976, 2012, 1977, 1976, 1980, 1980, 1980, 1980, 19…\n$ remaining_lease     &lt;chr&gt; \"55 years 07 months\", \"91 years 08 months\", \"56 ye…\n$ resale_price        &lt;dbl&gt; 265000, 470000, 230000, 280000, 220000, 280000, 24…\n$ year                &lt;dbl&gt; 2020, 2020, 2020, 2020, 2020, 2020, 2020, 2020, 20…\n$ quarter             &lt;dbl&gt; 2020.1, 2020.1, 2020.1, 2020.1, 2020.1, 2020.1, 20…\n$ price_per_sqm       &lt;dbl&gt; 3630.14, 6714.29, 3150.68, 3835.62, 3235.29, 4117.…\n$ storey_mid          &lt;dbl&gt; 5, 20, 2, 5, 8, 11, 5, 5, 2, 2, 8, 5, 2, 5, 2, 8, …\n$ flat_category       &lt;chr&gt; \"Medium (3 Room)\", \"Medium (3 Room)\", \"Medium (3 R…\n\n\n\n\n\nInstead of using fixed values, we calculate outlier boundaries dynamically using the IQR method for each flat type. This makes our analysis more robust and reproducible.\n\n# Calculate the lower and upper bounds for resale_price for each flat type\noutlier_bounds &lt;- engineered_data %&gt;%\n  group_by(flat_type) %&gt;%\n  summarise(\n    lower_bound = quantile(resale_price, 0.25, na.rm = TRUE) - 1.5 * IQR(resale_price, na.rm = TRUE),\n    upper_bound = quantile(resale_price, 0.75, na.rm = TRUE) + 1.5 * IQR(resale_price, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nprint(\"Calculated outlier bounds for resale price:\")\n\n[1] \"Calculated outlier bounds for resale price:\"\n\nprint(outlier_bounds)\n\n# A tibble: 7 × 3\n  flat_type        lower_bound upper_bound\n  &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;\n1 1 ROOM                137500      309500\n2 2 ROOM                150000      470000\n3 3 ROOM                165000      597000\n4 4 ROOM                215000      863000\n5 5 ROOM                267500     1007500\n6 EXECUTIVE             352500     1172500\n7 MULTI-GENERATION      507875     1242875\n\n# Sanity check for unrealistic values in the dataset\nquality_check &lt;- engineered_data %&gt;%\n  summarise(\n    negative_prices = sum(resale_price &lt; 0, na.rm = TRUE),\n    zero_areas = sum(floor_area_sqm &lt;= 0, na.rm = TRUE)\n  )\n\nprint(\"Data quality summary:\")\n\n[1] \"Data quality summary:\"\n\nprint(quality_check)\n\n# A tibble: 1 × 2\n  negative_prices zero_areas\n            &lt;int&gt;      &lt;int&gt;\n1               0          0\n\n\n\n\n\nWe filter the data for our project’s focus period (2020-2024) and remove outliers based on the dynamic bounds calculated in the previous step.\n\n# Join the outlier bounds to the main dataset and then filter\nproject_data &lt;- engineered_data %&gt;%\n  left_join(outlier_bounds, by = \"flat_type\") %&gt;%\n  filter(\n    # Filter for the project's time period\n    year &gt;= 2020 & year &lt;= 2024,\n    \n    # Dynamic outlier removal for price based on flat type\n    resale_price &gt;= lower_bound & resale_price &lt;= upper_bound,\n    \n    # Apply additional reasonable sanity checks\n    floor_area_sqm &gt; 20 & floor_area_sqm &lt; 250,\n    price_per_sqm &gt; 1000 & price_per_sqm &lt; 20000\n  ) %&gt;%\n  # Remove the temporary bound columns\n  select(-lower_bound, -upper_bound)\n\ncat(\"Final dataset dimensions after filtering:\", dim(project_data), \"\\n\")\n\nFinal dataset dimensions after filtering: 127606 16 \n\ncat(\"Years covered:\", paste(sort(unique(project_data$year)), collapse = \", \"), \"\\n\")\n\nYears covered: 2020, 2021, 2022, 2023, 2024 \n\n\n\n\n\nWe now create a summary table based on our clean, project-focused data.\n\nsummary_by_type_year &lt;- project_data %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(\n    transaction_count = n(),\n    median_price = median(resale_price, na.rm = TRUE),\n    mean_price = mean(resale_price, na.rm = TRUE),\n    median_psm = median(price_per_sqm, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Display summary for key flat types\nkey_flat_types &lt;- c(\"2 ROOM\", \"3 ROOM\", \"4 ROOM\", \"5 ROOM\", \"EXECUTIVE\")\nsummary_by_type_year %&gt;%\n  filter(flat_type %in% key_flat_types) %&gt;%\n  arrange(flat_type, year) %&gt;%\n  print(n = 25)\n\n# A tibble: 25 × 6\n   flat_type  year transaction_count median_price mean_price median_psm\n   &lt;chr&gt;     &lt;dbl&gt;             &lt;int&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 2 ROOM     2020               416       230000    233388.      5000 \n 2 2 ROOM     2021               382       265000    265938.      5745.\n 3 2 ROOM     2022               453       300000    295959.      6508.\n 4 2 ROOM     2023               681       320000    319504.      7021.\n 5 2 ROOM     2024               789       340000    339216.      7462.\n 6 3 ROOM     2020              5290       293000    306721.      4283.\n 7 3 ROOM     2021              6089       332000    344126.      4853.\n 8 3 ROOM     2022              6066       366000    376550.      5342.\n 9 3 ROOM     2023              6008       388000    396463.      5649.\n10 3 ROOM     2024              6302       410000    418791.      5976.\n11 4 ROOM     2020              9540       420000    443709.      4418.\n12 4 ROOM     2021             12080       468000    496212.      4969.\n13 4 ROOM     2022             10806       510000    531472.      5380.\n14 4 ROOM     2023             10692       541000    561019.      5714.\n15 4 ROOM     2024             10894       580000    591567.      6087.\n16 5 ROOM     2020              5927       506000    536509.      4274.\n17 5 ROOM     2021              7652       565944    594047.      4792.\n18 5 ROOM     2022              6504       615000    639271.      5180.\n19 5 ROOM     2023              5657       645000    669595.      5445.\n20 5 ROOM     2024              6100       680000    702131.      5771.\n21 EXECUTIVE  2020              1882       618000    635395.      4256.\n22 EXECUTIVE  2021              2256       690000    704865.      4762.\n23 EXECUTIVE  2022              1865       760000    777138.      5241.\n24 EXECUTIVE  2023              1482       810000    823433.      5594.\n25 EXECUTIVE  2024              1700       850000    859210.      5877.\n\n\n\n\n\nTo replicate and critique the original visualization, we calculate the percentage change in transactions from 2020 to 2024. We also create a flat_type_label for cleaner plotting.\n\npercentage_change &lt;- project_data %&gt;%\n  filter(year %in% c(2020, 2024)) %&gt;%\n  group_by(flat_type, year) %&gt;%\n  summarise(transaction_count = n(), .groups = \"drop\") %&gt;%\n  \n  complete(flat_type, year = c(2020, 2024), fill = list(transaction_count = 0)) %&gt;%\n  \n  pivot_wider(names_from = year, \n              values_from = transaction_count, \n              names_prefix = \"year_\") %&gt;%\n  \n  mutate(\n    percentage_change = if_else(year_2020 &gt; 0, \n                                round(((year_2024 - year_2020) / year_2020) * 100, 1), \n                                NA_real_), # Set to NA if 2020 count is 0\n    absolute_change = year_2024 - year_2020,\n    # Create a clean label for plotting\n    flat_type_label = str_replace(flat_type, \" ROOM\", \"-room\") %&gt;% str_to_title()\n  ) %&gt;%\n  arrange(desc(percentage_change))\n\nprint(\"Percentage change in transactions (2020-2024):\")\n\n[1] \"Percentage change in transactions (2020-2024):\"\n\nprint(percentage_change)\n\n# A tibble: 7 × 6\n  flat_type        year_2020 year_2024 percentage_change absolute_change\n  &lt;chr&gt;                &lt;int&gt;     &lt;int&gt;             &lt;dbl&gt;           &lt;int&gt;\n1 2 ROOM                 416       789              89.7             373\n2 3 ROOM                5290      6302              19.1            1012\n3 4 ROOM                9540     10894              14.2            1354\n4 1 ROOM                  10        11              10                 1\n5 5 ROOM                5927      6100               2.9             173\n6 EXECUTIVE             1882      1700              -9.7            -182\n7 MULTI-GENERATION         8         6             -25                -2\n# ℹ 1 more variable: flat_type_label &lt;chr&gt;\n\n\n\n\n\nWe save the cleaned data and summary tables to CSV files for use in our visualization tools and final report.\n\n# Create a 'data_output' directory if it doesn't exist\nif (!dir.exists(\"data_output\")) {\n  dir.create(\"data_output\")\n}\n\n# Save the final datasets\nwrite_csv(project_data, \"data_output/cleaned_hdb_resale_data.csv\")\nwrite_csv(summary_by_type_year, \"data_output/summary_by_type_year.csv\")\nwrite_csv(percentage_change, \"data_output/percentage_change_analysis.csv\")\n\ncat(\"Data cleaning completed successfully!\\n\")\n\nData cleaning completed successfully!\n\ncat(\"Files saved in 'data_output/' directory.\\n\")\n\nFiles saved in 'data_output/' directory.\n\n\n\n\n\nA final check to confirm the state of our prepared dataset.\n\nvalidation_summary &lt;- list(\n  total_records = nrow(project_data),\n  date_range = paste(min(project_data$month), \"to\", max(project_data$month)),\n  flat_types_count = length(unique(project_data$flat_type)),\n  towns_count = length(unique(project_data$town)),\n  years = sort(unique(project_data$year)),\n  price_range = paste0(\"$\", format(min(project_data$resale_price), big.mark = \",\"), \n                      \" to $\", format(max(project_data$resale_price), big.mark = \",\")),\n  missing_values_final = sum(is.na(project_data))\n)\n\ncat(\"=== DATA VALIDATION SUMMARY ===\\n\")\n\n=== DATA VALIDATION SUMMARY ===\n\ncat(\"Total records in final dataset:\", validation_summary$total_records, \"\\n\")\n\nTotal records in final dataset: 127606 \n\ncat(\"Date range:\", validation_summary$date_range, \"\\n\")\n\nDate range: 2020-01-01 to 2024-12-01 \n\ncat(\"Number of unique flat types:\", validation_summary$flat_types_count, \"\\n\")\n\nNumber of unique flat types: 7 \n\ncat(\"Number of unique towns:\", validation_summary$towns_count, \"\\n\")\n\nNumber of unique towns: 26 \n\ncat(\"Years covered:\", paste(validation_summary$years, collapse = \", \"), \"\\n\")\n\nYears covered: 2020, 2021, 2022, 2023, 2024 \n\ncat(\"Final price range:\", validation_summary$price_range, \"\\n\")\n\nFinal price range: $150,000 to $1,200,000 \n\ncat(\"Total missing values in final dataset:\", validation_summary$missing_values_final, \"\\n\")\n\nTotal missing values in final dataset: 0 \n\ncat(\"===============================\\n\")\n\n==============================="
  }
]